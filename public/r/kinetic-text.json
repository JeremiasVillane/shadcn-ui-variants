{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "kinetic-text",
  "type": "registry:ui",
  "title": "Kinetic Text",
  "description": "The KineticText component, built upon the versatile Kinetic component, offers a powerful way to create engaging and dynamic text animations.",
  "dependencies": [
    "motion"
  ],
  "registryDependencies": [
    "https://shadcn-ui-variants.vercel.app/r/kinetic.json"
  ],
  "files": [
    {
      "path": "components/ui/kinetic-text.tsx",
      "content": "\"use client\"\r\n\r\nimport * as React from \"react\"\r\nimport { useScroll } from \"motion/react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nimport { Kinetic, type KineticProps } from \"./kinetic\"\r\n\r\ninterface KineticTextProps\r\n  extends Omit<\r\n    KineticProps,\r\n    | \"children\"\r\n    | \"staggerIndex\" // Internal to KineticText's mapping\r\n    | \"scrollStaggerAmount\" // KineticText calculates this for children\r\n    | \"externalScrollProgress\" // KineticText provides this to children\r\n    | \"isParentScrollRangeCustom\" // KineticText provides this to children\r\n    | \"segmentScrollSpan\" // KineticText calculates this for children\r\n    | \"delay\" // KineticText manages baseDelay + stagger for time-based\r\n  > {\r\n  /**  The text content to animate. */\r\n  children: string\r\n\r\n  /** How to segment the text for animation.\r\n   * - \"text\": Animate the entire text as one block.\r\n   * - \"word\": Animate each word individually.\r\n   * - \"character\": Animate each character individually.\r\n   * - \"line\": Animate each line (separated by newline characters) individually.\r\n   */\r\n  by?: \"text\" | \"word\" | \"character\" | \"line\"\r\n\r\n  /** Time-based stagger. Applied if onScroll is false. @default 0.05 */\r\n  stagger?: number\r\n\r\n  /** Scroll-based stagger \"intensity\" (0 to 1, ideally < 0.5).\r\n   * Determines how much overlap exists between segment animations.\r\n   * Smaller value = more overlap / faster sequence.\r\n   * Larger value = less overlap / more sequential.\r\n   * The component will try to fit all segments based on this and segmentScrollOverlap.\r\n   * @default 0.2 */\r\n  scrollStagger?: number\r\n\r\n  /** Scroll-based. A hint (0 to 1) for how much each segment's animation should overlap with the next.\r\n   * 0 means segments play sequentially after one another.\r\n   * 0.5 means next segment starts when current is 50% done with its span.\r\n   * 1 means all segments effectively start together (max overlap).\r\n   * This is used to derive segmentScrollSpan and effectiveScrollStagger.\r\n   * @default 0.7 */\r\n  scrollSegmentOverlap?: number\r\n\r\n  /** Base delay for the entire animation sequence */\r\n  delay?: number\r\n\r\n  className?: string\r\n\r\n  style?: React.CSSProperties\r\n\r\n  /**\r\n   * Whether to enable scroll-based animations\r\n   * When enabled, animation progress is tied to scroll position\r\n   * @default false */\r\n  onScroll?: KineticProps[\"onScroll\"]\r\n\r\n  /**\r\n   * Defines the point (in pixels) from the top of the viewport at which the scroll-driven animation completes.\r\n   * Specifically, `scrollYProgress` will reach 1 when the top of the animating element is this many pixels\r\n   * from the top of the viewport. The animation (e.g., fade-in) will then map directly to this 0-1 progress.\r\n   * Only applies if `onScroll` is true. If undefined, the animation plays out over a default portion\r\n   * of the element's visibility duration in the viewport.\r\n   */\r\n  offset?: KineticProps[\"offset\"]\r\n}\r\n\r\nconst KineticText: React.FC<KineticTextProps> = ({\r\n  children: textContent,\r\n  by = \"character\",\r\n  stagger = 0.05,\r\n  scrollStagger: userScrollStaggerHint = 0.2,\r\n  scrollSegmentOverlap = 0.7,\r\n  className: containerClassName,\r\n  style: containerStyleProp,\r\n  delay: baseDelay = 0,\r\n  onScroll = false,\r\n  offset,\r\n  ...kineticPassThroughProps\r\n}) => {\r\n  const kineticTextWrapperRef = React.useRef<HTMLDivElement>(null)\r\n\r\n  const animatableSegments = React.useMemo(() => {\r\n    if (!textContent) return []\r\n    const segments: string[] = []\r\n    if (by === \"word\") {\r\n      const parts = textContent.split(/(\\s+)/)\r\n      parts.forEach((part) => {\r\n        if (part.length > 0 && !part.match(/^\\s+$/)) {\r\n          segments.push(part)\r\n        }\r\n      })\r\n    } else if (by === \"character\") {\r\n      textContent.split(\"\").forEach((char) => {\r\n        segments.push(char === \" \" ? \"\\u00A0\" : char)\r\n      })\r\n    } else if (by === \"line\") {\r\n      textContent.split(\"\\n\").forEach((line) => {\r\n        // Allow empty lines as animatable segments for layout purposes\r\n        segments.push(line)\r\n      })\r\n    } else {\r\n      segments.push(textContent)\r\n    }\r\n    return segments\r\n  }, [textContent, by])\r\n\r\n  const numAnimatableSegments = animatableSegments.length\r\n\r\n  const { effectiveScrollStagger, effectiveSegmentScrollSpan } =\r\n    React.useMemo(() => {\r\n      if (!onScroll || numAnimatableSegments <= 0) {\r\n        return { effectiveScrollStagger: 0, effectiveSegmentScrollSpan: 0 }\r\n      }\r\n      if (numAnimatableSegments === 1) {\r\n        return { effectiveScrollStagger: 0, effectiveSegmentScrollSpan: 1.0 }\r\n      }\r\n\r\n      // Ensure overlap is between 0 (no overlap beyond sequential start) and just under 1 (max overlap)\r\n      const overlapFactor = Math.max(0, Math.min(0.99, scrollSegmentOverlap))\r\n\r\n      let effSpan =\r\n        1.0 / ((numAnimatableSegments - 1) * (1 - overlapFactor) + 1)\r\n      let effStagger = effSpan * (1 - overlapFactor)\r\n\r\n      // Let D be segment span, S be stagger.\r\n      // (N-1)S + D = 1 (total progress used)\r\n      // S = D * k (stagger is k * span, where k might be related to 1 - scrollSegmentOverlap)\r\n      // (N-1)Dk + D = 1 => D * ((N-1)k + 1) = 1 => D = 1 / ((N-1)k + 1)\r\n      // Let k = (1 - scrollSegmentOverlap), which is \"how much of the segment plays before next starts\"\r\n      const k = Math.max(0.01, 1 - overlapFactor) // k must be > 0 if N > 1\r\n\r\n      effSpan = 1.0 / ((numAnimatableSegments - 1) * k + 1)\r\n      effStagger = effSpan * k\r\n\r\n      // Safety check: if N=1, above gives D=1, S=0 (as k doesn't matter) - this is covered by N===1 case.\r\n      if (numAnimatableSegments <= 1) {\r\n        // Ensure for N=1, span is 1 and stagger is 0\r\n        effSpan = 1.0\r\n        effStagger = 0\r\n      }\r\n\r\n      return {\r\n        effectiveScrollStagger: effStagger,\r\n        effectiveSegmentScrollSpan: effSpan\r\n      }\r\n    }, [onScroll, numAnimatableSegments, scrollSegmentOverlap])\r\n\r\n  const containerStyles: React.CSSProperties = { ...containerStyleProp }\r\n  if (by === \"word\" || by === \"character\") {\r\n    containerStyles.display = \"flex\"\r\n    containerStyles.flexWrap = \"wrap\"\r\n  }\r\n\r\n  const isParentUsingCustomOffset = typeof offset === \"number\" && onScroll\r\n  const parentScrollHook = useScroll({\r\n    target: kineticTextWrapperRef,\r\n    offset: isParentUsingCustomOffset\r\n      ? [\"start end\", `start ${offset}px`]\r\n      : [\"start end\", \"end start\"]\r\n  })\r\n  const parentScrollYProgress = onScroll\r\n    ? parentScrollHook.scrollYProgress\r\n    : undefined\r\n\r\n  // Reconstruct the original segments (including spaces for words) for rendering\r\n  const renderSegments = React.useMemo(() => {\r\n    if (!textContent) return []\r\n    if (by === \"word\") {\r\n      return textContent\r\n        .split(/(\\s+)/)\r\n        .map((part, i) => ({\r\n          key: `word-part-${i}`,\r\n          isSpace: part.match(/^\\s+$/),\r\n          content: part\r\n        }))\r\n        .filter((p) => p.content.length > 0)\r\n    }\r\n    // Other `by` types already produce an array of strings that are all animatable\r\n    return animatableSegments.map((seg, i) => ({\r\n      key: `${by}-${i}`,\r\n      isSpace: false,\r\n      content: seg\r\n    }))\r\n  }, [textContent, by, animatableSegments])\r\n\r\n  let currentAnimatableIndex = 0\r\n\r\n  return (\r\n    <div\r\n      ref={kineticTextWrapperRef}\r\n      className={cn(\"kinetic-text-wrapper\", containerClassName)}\r\n      style={containerStyles}\r\n    >\r\n      {renderSegments.map((segmentItem, idx) => {\r\n        if (segmentItem.isSpace && by === \"word\") {\r\n          return (\r\n            <span key={segmentItem.key} style={{ whiteSpace: \"pre-wrap\" }}>\r\n              {segmentItem.content}\r\n            </span>\r\n          )\r\n        }\r\n\r\n        // For line breaks in 'line' mode, if a segment is empty, render a placeholder or skip\r\n        if (segmentItem.content === \"\" && by === \"line\") {\r\n          return (\r\n            <div\r\n              key={segmentItem.key}\r\n              style={{ height: \"1em\" }}\r\n              aria-hidden=\"true\"\r\n            />\r\n          )\r\n        }\r\n        // Skip any other generally empty animatable segments\r\n        if (segmentItem.content === \"\") return null\r\n\r\n        const animatableIndexForStagger = currentAnimatableIndex\r\n        currentAnimatableIndex++\r\n\r\n        const segmentTimeDelay = baseDelay + animatableIndexForStagger * stagger\r\n\r\n        return (\r\n          <Kinetic\r\n            key={segmentItem.key}\r\n            {...kineticPassThroughProps}\r\n            onScroll={onScroll}\r\n            externalScrollProgress={parentScrollYProgress}\r\n            isParentScrollRangeCustom={\r\n              onScroll ? isParentUsingCustomOffset : undefined\r\n            }\r\n            delay={onScroll ? undefined : segmentTimeDelay}\r\n            staggerIndex={onScroll ? animatableIndexForStagger : undefined}\r\n            scrollStaggerAmount={onScroll ? effectiveScrollStagger : undefined}\r\n            segmentScrollSpan={\r\n              onScroll ? effectiveSegmentScrollSpan : undefined\r\n            }\r\n          >\r\n            {segmentItem.content}\r\n          </Kinetic>\r\n        )\r\n      })}\r\n    </div>\r\n  )\r\n}\r\nKineticText.displayName = \"KineticText\"\r\n\r\nexport { KineticText }\r\nexport type { KineticTextProps }\r\n",
      "type": "registry:ui"
    }
  ]
}