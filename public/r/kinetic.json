{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "kinetic",
  "type": "registry:ui",
  "title": "Kinetic",
  "description": "A flexible wrapper component for framer-motion animations.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "components/ui/kinetic.tsx",
      "content": "\"use client\"\r\n\r\nimport * as React from \"react\"\r\nimport {\r\n  motion,\r\n  useInView,\r\n  useScroll,\r\n  useTransform,\r\n  type MotionProps,\r\n  type MotionValue,\r\n  type Variants\r\n} from \"motion/react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\ninterface KineticProps extends Omit<MotionProps, \"transition\"> {\r\n  /**\r\n   * The animation variant to apply. Can be a predefined string or custom Variants object.\r\n   */\r\n  // prettier-ignore\r\n  animation?: \"fadeIn\" | \"fadeInUp\" | \"fadeInDown\" | \"fadeInLeft\" | \"fadeInRight\" | \"scaleIn\" | \"slideInUp\" | \"slideInDown\" | \"slideInLeft\" | \"slideInRight\" | \"blurIn\" | \"blurInUp\" | \"blurInDown\" | \"blurInLeft\" | \"blurInRight\" | \"rotateIn\" | \"bounce\" | \"elastic\" | Variants\r\n\r\n  /**\r\n   * Duration of the animation in seconds\r\n   * @default 0.5 */\r\n  duration?: number\r\n\r\n  /**\r\n   * Delay before the animation starts in seconds\r\n   * @default 0 */\r\n  delay?: number\r\n\r\n  /**\r\n   * Whether the animation should start only when the component enters the viewport\r\n   * @default false */\r\n  startOnView?: boolean\r\n\r\n  /**\r\n   * Whether the animation should play only once or every time it enters the viewport\r\n   * Only applies when startOnView is true\r\n   * @default true */\r\n  once?: boolean\r\n\r\n  /**\r\n   * Whether the animation should repeat indefinitely\r\n   * @default false */\r\n  loop?: boolean\r\n\r\n  /**\r\n   * Whether to enable scroll-based animations\r\n   * When enabled, animation progress is tied to scroll position\r\n   * @default false */\r\n  onScroll?: boolean\r\n\r\n  /**\r\n   * Defines the point (in pixels) from the top of the viewport at which the scroll-driven animation completes.\r\n   * Specifically, `scrollYProgress` will reach 1 when the top of the animating element is this many pixels\r\n   * from the top of the viewport. The animation (e.g., fade-in) will then map directly to this 0-1 progress.\r\n   * Only applies if `onScroll` is true. If undefined, the animation plays out over a default portion\r\n   * of the element's visibility duration in the viewport.\r\n   */\r\n  offset?: number\r\n\r\n  /**\r\n   * Custom className for the wrapper\r\n   */\r\n  className?: string\r\n\r\n  /**\r\n   * Children to animate\r\n   */\r\n  children: React.ReactNode\r\n\r\n  // /**\r\n  //  * HTML element type to render\r\n  //  * @default 'div' */\r\n  // as?: keyof HTMLElementTagNameMap\r\n\r\n  /**\r\n   * Viewport options for intersection observer\r\n   */\r\n  viewportOptions?: {\r\n    root?: Element | null\r\n    margin?:\r\n      | `${number}% ${number}% ${number}% ${number}%`\r\n      | `${number}px ${number}px ${number}px ${number}px`\r\n    amount?: number | \"some\" | \"all\"\r\n  }\r\n\r\n  /**\r\n   * Custom transition properties\r\n   */\r\n  transition?: MotionProps[\"transition\"]\r\n\r\n  /** Optional user-provided style */\r\n  style?: React.CSSProperties\r\n}\r\n\r\nconst predefinedAnimations: Record<string, Variants> = {\r\n  fadeIn: { hidden: { opacity: 0 }, visible: { opacity: 1 } },\r\n  fadeInUp: { hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0 } },\r\n  fadeInDown: { hidden: { opacity: 0, y: -20 }, visible: { opacity: 1, y: 0 } },\r\n  fadeInLeft: { hidden: { opacity: 0, x: -20 }, visible: { opacity: 1, x: 0 } },\r\n  fadeInRight: { hidden: { opacity: 0, x: 20 }, visible: { opacity: 1, x: 0 } },\r\n  scaleIn: {\r\n    hidden: { opacity: 0, scale: 0.8 },\r\n    visible: { opacity: 1, scale: 1 }\r\n  },\r\n  slideInUp: { hidden: { y: 50, opacity: 0 }, visible: { y: 0, opacity: 1 } },\r\n  slideInDown: {\r\n    hidden: { y: -50, opacity: 0 },\r\n    visible: { y: 0, opacity: 1 }\r\n  },\r\n  slideInLeft: {\r\n    hidden: { x: -50, opacity: 0 },\r\n    visible: { x: 0, opacity: 1 }\r\n  },\r\n  slideInRight: {\r\n    hidden: { x: 50, opacity: 0 },\r\n    visible: { x: 0, opacity: 1 }\r\n  },\r\n  blurIn: {\r\n    hidden: { filter: \"blur(10px)\", opacity: 0 },\r\n    visible: { filter: \"blur(0px)\", opacity: 1 }\r\n  },\r\n  blurInUp: {\r\n    hidden: { opacity: 0, y: 20, filter: \"blur(6px)\" },\r\n    visible: { opacity: 1, y: 0, filter: \"blur(0px)\" }\r\n  },\r\n  blurInDown: {\r\n    hidden: { opacity: 0, y: -20, filter: \"blur(6px)\" },\r\n    visible: { opacity: 1, y: 0, filter: \"blur(0px)\" }\r\n  },\r\n  blurInLeft: {\r\n    hidden: { opacity: 0, x: -20, filter: \"blur(6px)\" },\r\n    visible: { opacity: 1, x: 0, filter: \"blur(0px)\" }\r\n  },\r\n  blurInRight: {\r\n    hidden: { opacity: 0, x: 20, filter: \"blur(6px)\" },\r\n    visible: { opacity: 1, x: 0, filter: \"blur(0px)\" }\r\n  },\r\n  rotateIn: {\r\n    hidden: { opacity: 0, rotate: -180 },\r\n    visible: { opacity: 1, rotate: 0 }\r\n  },\r\n  bounce: {\r\n    hidden: { opacity: 0, y: -20 },\r\n    visible: {\r\n      opacity: 1,\r\n      y: 0,\r\n      transition: { type: \"spring\", bounce: 0.7, duration: 0.8 }\r\n    }\r\n  },\r\n  elastic: {\r\n    hidden: { opacity: 0, scale: 0 },\r\n    visible: {\r\n      opacity: 1,\r\n      scale: 1,\r\n      transition: { type: \"spring\", stiffness: 400, damping: 10 }\r\n    }\r\n  }\r\n}\r\n\r\nconst calculateTransformAnimationParams = (\r\n  propKey: string, // e.g., \"opacity\", \"y\", \"filter\"\r\n  isOnScroll: boolean,\r\n  passedVariants: Variants | undefined, // The variants resolved for the current animation\r\n  animationName: KineticProps[\"animation\"], // String name if predefined, or the custom Variants object\r\n  isCustomScrollOffsetActive: boolean\r\n) => {\r\n  let defaultTargetVisibleVal: string | number\r\n  switch (propKey) {\r\n    case \"opacity\":\r\n      defaultTargetVisibleVal = 1\r\n      break\r\n    case \"scale\":\r\n      defaultTargetVisibleVal = 1\r\n      break\r\n    case \"filter\":\r\n      defaultTargetVisibleVal = \"blur(0px)\"\r\n      break // Target is no blur\r\n    case \"x\":\r\n      defaultTargetVisibleVal = 0\r\n      break\r\n    case \"y\":\r\n      defaultTargetVisibleVal = 0\r\n      break\r\n    case \"rotate\":\r\n      defaultTargetVisibleVal = 0\r\n      break\r\n    default:\r\n      defaultTargetVisibleVal = 0\r\n      break\r\n  }\r\n\r\n  if (!isOnScroll) {\r\n    // Return a non-animating range if not on scroll\r\n    return {\r\n      inputRange: [0, 1] as [number, number],\r\n      outputRange: [defaultTargetVisibleVal, defaultTargetVisibleVal] as [\r\n        string | number,\r\n        string | number\r\n      ],\r\n      defined: false\r\n    }\r\n  }\r\n\r\n  // Determine the input range for useTransform based on whether a custom offset is active\r\n  const scrollInputRange: [number, number] = isCustomScrollOffsetActive\r\n    ? [0, 1] // Use full 0-1 range of scrollYProgress\r\n    : [0.15, 0.85] // Default: animate between 15% and 85% of scrollYProgress\r\n\r\n  // Prioritize values from the passedVariants\r\n  const variantVisibleVal = (passedVariants?.visible as any)?.[propKey]\r\n  let variantHiddenVal = (passedVariants?.hidden as any)?.[propKey]\r\n\r\n  // Determine final visible value: Use variant's value or the default target.\r\n  const finalVisibleVal = variantVisibleVal ?? defaultTargetVisibleVal\r\n\r\n  if (variantHiddenVal === undefined) {\r\n    if (\r\n      typeof animationName === \"string\" &&\r\n      predefinedAnimations[animationName]\r\n    ) {\r\n      variantHiddenVal = (predefinedAnimations[animationName].hidden as any)?.[\r\n        propKey\r\n      ]\r\n    }\r\n\r\n    if (variantHiddenVal === undefined) {\r\n      switch (propKey) {\r\n        case \"opacity\":\r\n          variantHiddenVal = 0\r\n          break\r\n        case \"scale\":\r\n          variantHiddenVal =\r\n            finalVisibleVal === 1\r\n              ? 0.8\r\n              : typeof finalVisibleVal === \"number\"\r\n                ? finalVisibleVal * 0.8\r\n                : finalVisibleVal\r\n          break\r\n        case \"filter\":\r\n          variantHiddenVal =\r\n            finalVisibleVal === \"blur(0px)\" || finalVisibleVal === \"none\"\r\n              ? \"blur(8px)\"\r\n              : finalVisibleVal\r\n          break\r\n        case \"x\":\r\n          variantHiddenVal = finalVisibleVal === 0 ? 20 : finalVisibleVal\r\n          break // Default slide-in from right-ish\r\n        case \"y\":\r\n          variantHiddenVal = finalVisibleVal === 0 ? 20 : finalVisibleVal\r\n          break // Default slide-in from bottom-ish\r\n        case \"rotate\":\r\n          variantHiddenVal = finalVisibleVal === 0 ? -90 : finalVisibleVal\r\n          break\r\n        default:\r\n          variantHiddenVal = finalVisibleVal\r\n          break\r\n      }\r\n    }\r\n  }\r\n  const finalHiddenVal = variantHiddenVal\r\n\r\n  // Determine if this property should actually animate via scroll\r\n  let shouldAnimateProperty = false\r\n  const isPropInVariantVisible =\r\n    (passedVariants?.visible as any)?.[propKey] !== undefined\r\n  const isPropInVariantHidden =\r\n    (passedVariants?.hidden as any)?.[propKey] !== undefined\r\n\r\n  if (isPropInVariantVisible || isPropInVariantHidden) {\r\n    // If the property is explicitly mentioned in the variant, animate if values differ.\r\n    shouldAnimateProperty = finalHiddenVal !== finalVisibleVal\r\n  } else if (propKey === \"opacity\") {\r\n    // Opacity has a common implicit animation (0 to 1), animate if different.\r\n    shouldAnimateProperty = finalHiddenVal !== finalVisibleVal\r\n  }\r\n  // Other properties (filter, x, y, scale, rotate) will not animate by default if not in variants.\r\n\r\n  return {\r\n    inputRange: scrollInputRange,\r\n    outputRange: [\r\n      finalHiddenVal as string | number,\r\n      finalVisibleVal as string | number\r\n    ],\r\n    defined: shouldAnimateProperty\r\n  }\r\n}\r\n\r\nconst Kinetic = React.forwardRef<HTMLElement, KineticProps>(\r\n  (\r\n    {\r\n      animation = \"fadeIn\",\r\n      duration = 0.5,\r\n      delay = 0,\r\n      startOnView = false,\r\n      once = true,\r\n      loop = false,\r\n      onScroll = false,\r\n      offset,\r\n      className,\r\n      children,\r\n      viewportOptions = {},\r\n      transition: customTransition,\r\n      style: userStyle,\r\n      ...props\r\n    },\r\n    forwardedRef\r\n  ) => {\r\n    const viewRef = React.useRef<HTMLElement>(null)\r\n\r\n    const setRefs = React.useCallback(\r\n      (node: HTMLElement | null) => {\r\n        ;(viewRef as React.MutableRefObject<HTMLElement | null>).current = node\r\n        if (typeof forwardedRef === \"function\") {\r\n          forwardedRef(node)\r\n        } else if (forwardedRef) {\r\n          ;(\r\n            forwardedRef as React.MutableRefObject<HTMLElement | null>\r\n          ).current = node\r\n        }\r\n      },\r\n      [forwardedRef]\r\n    )\r\n\r\n    const resolvedAnimationVariants = React.useMemo(() => {\r\n      let baseVariants =\r\n        typeof animation === \"string\"\r\n          ? predefinedAnimations[animation] || predefinedAnimations.fadeIn\r\n          : animation\r\n\r\n      if (!baseVariants) return predefinedAnimations.fadeIn\r\n\r\n      const animationIsString = typeof animation === \"string\"\r\n\r\n      if (\r\n        animationIsString &&\r\n        (animation === \"bounce\" || animation === \"elastic\")\r\n      ) {\r\n        // Deep clone to avoid mutating predefinedAnimations and allow instance-specific modifications\r\n        const newVariants = JSON.parse(JSON.stringify(baseVariants))\r\n\r\n        if (newVariants.visible) {\r\n          const originalVariantTransition =\r\n            typeof baseVariants.visible === \"object\" &&\r\n            baseVariants.visible !== null &&\r\n            \"transition\" in baseVariants.visible\r\n              ? (baseVariants.visible as { transition?: any }).transition || {}\r\n              : {}\r\n\r\n          newVariants.visible.transition = {\r\n            type: \"spring\",\r\n            ...originalVariantTransition\r\n          }\r\n\r\n          if (typeof duration === \"number\") {\r\n            newVariants.visible.transition.duration = duration // Set/override duration\r\n\r\n            // For \"elastic\" specifically: if we're applying a component-level duration,\r\n            // remove its predefined physical properties to let the new `duration` primarily drive the spring behavior.\r\n            if (animation === \"elastic\") {\r\n              delete newVariants.visible.transition.stiffness\r\n              delete newVariants.visible.transition.damping\r\n              delete newVariants.visible.transition.mass\r\n            }\r\n          }\r\n          // If `typeof duration !== 'number'`, the newVariants.visible.transition will retain\r\n          // its original properties from baseVariants (e.g., bounce's original duration,\r\n          // or elastic's original stiffness/damping), because they were spread from\r\n          // originalVariantTransition and not subsequently overridden or deleted.\r\n\r\n          // If loop is true, also inject loop properties into the variant's transition\r\n          if (loop) {\r\n            newVariants.visible.transition.repeat = Number.POSITIVE_INFINITY\r\n            newVariants.visible.transition.repeatType = \"loop\"\r\n          }\r\n          return newVariants\r\n        }\r\n      }\r\n\r\n      // For other animations or custom variant objects, return them as is.\r\n      // Loop for these is handled by `componentBaseTransition`.\r\n      return baseVariants\r\n    }, [animation, loop, duration])\r\n\r\n    const rootRefForInView = React.useRef<Element | null>(\r\n      viewportOptions.root ?? null\r\n    )\r\n    const isInView = useInView(viewRef, {\r\n      once: onScroll ? false : once,\r\n      margin: viewportOptions.margin,\r\n      amount: viewportOptions.amount,\r\n      root: rootRefForInView\r\n    })\r\n\r\n    const isCustomScrollOffsetActive = typeof offset === \"number\" && onScroll\r\n\r\n    const { scrollYProgress } = useScroll({\r\n      target: viewRef,\r\n      offset: isCustomScrollOffsetActive\r\n        ? [\"start end\", `start ${offset}px`]\r\n        : [\"start end\", \"end start\"]\r\n    })\r\n\r\n    // --- Scroll-driven animation setup ---\r\n    const opacityAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"opacity\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const opacityScroll = useTransform(\r\n      scrollYProgress,\r\n      opacityAnimParams.inputRange,\r\n      opacityAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const xAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"x\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const xScroll = useTransform(\r\n      scrollYProgress,\r\n      xAnimParams.inputRange,\r\n      xAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const yAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"y\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const yScroll = useTransform(\r\n      scrollYProgress,\r\n      yAnimParams.inputRange,\r\n      yAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const scaleAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"scale\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const scaleScroll = useTransform(\r\n      scrollYProgress,\r\n      scaleAnimParams.inputRange,\r\n      scaleAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const rotateAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"rotate\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const rotateScroll = useTransform(\r\n      scrollYProgress,\r\n      rotateAnimParams.inputRange,\r\n      rotateAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const filterAnimParams = React.useMemo(\r\n      () =>\r\n        calculateTransformAnimationParams(\r\n          \"filter\",\r\n          onScroll,\r\n          resolvedAnimationVariants,\r\n          animation,\r\n          isCustomScrollOffsetActive\r\n        ),\r\n      [\r\n        onScroll,\r\n        resolvedAnimationVariants,\r\n        animation,\r\n        isCustomScrollOffsetActive\r\n      ]\r\n    )\r\n    const filterScroll = useTransform(\r\n      scrollYProgress,\r\n      filterAnimParams.inputRange,\r\n      filterAnimParams.outputRange,\r\n      { clamp: true }\r\n    )\r\n\r\n    const scrollDrivenStyles = React.useMemo(() => {\r\n      if (!onScroll) return {}\r\n      const styles: Record<string, MotionValue | string | number> = {}\r\n      if (opacityAnimParams.defined) styles.opacity = opacityScroll\r\n      if (xAnimParams.defined) styles.x = xScroll\r\n      if (yAnimParams.defined) styles.y = yScroll\r\n      if (scaleAnimParams.defined) styles.scale = scaleScroll\r\n      if (rotateAnimParams.defined) styles.rotate = rotateScroll\r\n      if (filterAnimParams.defined) styles.filter = filterScroll\r\n      return styles\r\n    }, [\r\n      onScroll,\r\n      opacityAnimParams,\r\n      xAnimParams,\r\n      yAnimParams,\r\n      scaleAnimParams,\r\n      rotateAnimParams,\r\n      filterAnimParams,\r\n      opacityScroll,\r\n      xScroll,\r\n      yScroll,\r\n      scaleScroll,\r\n      rotateScroll,\r\n      filterScroll\r\n    ])\r\n    // --- End of scroll-driven animation setup ---\r\n\r\n    const animateControl = React.useMemo(() => {\r\n      if (onScroll) return undefined\r\n      if (startOnView) return isInView ? \"visible\" : \"hidden\"\r\n      return \"visible\"\r\n    }, [onScroll, startOnView, isInView])\r\n\r\n    const componentBaseTransition = React.useMemo(() => {\r\n      if (onScroll) return undefined\r\n      const trans: MotionProps[\"transition\"] = {\r\n        duration:\r\n          typeof animation === \"string\" &&\r\n          (animation === \"bounce\" || animation === \"elastic\")\r\n            ? undefined\r\n            : duration,\r\n        delay,\r\n        ...customTransition\r\n      }\r\n      if (loop) {\r\n        trans.repeat = Number.POSITIVE_INFINITY\r\n        trans.repeatType = \"loop\"\r\n      }\r\n      return trans\r\n    }, [onScroll, duration, delay, loop, customTransition, animation])\r\n\r\n    const motionComponentProps: MotionProps & Record<string, any> = { ...props }\r\n\r\n    if (onScroll) {\r\n      motionComponentProps.style = { ...userStyle, ...scrollDrivenStyles }\r\n    } else {\r\n      motionComponentProps.variants = resolvedAnimationVariants\r\n      motionComponentProps.initial = \"hidden\"\r\n      motionComponentProps.animate = animateControl\r\n      motionComponentProps.transition = componentBaseTransition\r\n      if (userStyle) {\r\n        motionComponentProps.style = {\r\n          ...(motionComponentProps.style || {}),\r\n          ...userStyle\r\n        }\r\n      }\r\n    }\r\n\r\n    return (\r\n      <motion.div\r\n        ref={setRefs}\r\n        className={cn(className)}\r\n        {...motionComponentProps}\r\n      >\r\n        {children}\r\n      </motion.div>\r\n    )\r\n  }\r\n)\r\n\r\nKinetic.displayName = \"Kinetic\"\r\n\r\nexport { Kinetic }\r\nexport type { KineticProps }\r\n",
      "type": "registry:ui"
    }
  ]
}